# 1장_협력하는 객체들의 공동체

### 객체 지향은 현실 세계의 모방인가?

여기에 대한 나의 대답은 `“그렇긴 하지만 그렇지 않다”` 이다.

실제로 나도 설계를 할 때 네이밍이나 여러가지 객체 덩어리 들은 현실과 같이 생각한다.

하지만 둘이 같냐? 그렇지 않다.

카드게임을 한다고 생각하면

현실 세계에서는 딜러가 카드를 줘야하지만 사실 카드뭉치가 카드를 줄 수 도 있다.

이러한 편이 설계적으로 더 깔끔하기 때문이다.

나는 사실 객체 지향은 만화라고 생각한다.

위 책에서 예로 든 엘리스 처럼 만화같은 일이 벌어질 수 있는 곳이 객체 지향의 세계라고 생각한다.

책에서 말하는 역할의 특징 중

> 한 사람이 동시에 여러 역할을 수행할 수 있다
>

라는 문장이 있다.

이 말에는 동의하지 못하겠다.

물론 아직 초반이라 설명을 따로 안한 건가? 싶긴 하지만

SRP에 어긋난다고 생각한다.

### 객체의 덕목 두 가지

1. 협력적

   객체는 서로 응답을 주고 받으며 일을 처리함

2. 자율적

   객체는 스스로 판단을 할 줄 알아야함


# 2장_이상한 나라의 객체

우리는 인지적으로 무언가를 파악할 때 작게 나누려고 함

그래야 복잡성이 줄어들기 때문이다.

이는 객체 지향에서도 똑같다.

가장 작은 단위를 찾아 나가며 객체의 복잡성을 줄이려고 노력한다.

### 엘리스

엘리스라는 객체를 살펴보자

뭔지 쳐먹으면 키가 커지고 뭘 잘못 쳐먹으면 키가 작아진다.

즉, 엘리스의 `행동에` 따라 키가 결정된다.

다시 말하면 엘리스의 `행동에` 따라 엘리스의 `상태가` 결정된다.

그리고 많이 쳐먹어서 키가 커지면 문을 통과 못한다.

하지만 라마단 기간이라 못 쳐먹었으면 문을 통과할 수 있다.

이는 `행동의 순서`에도 영향을 미친다는 뜻이다.

또한 `행동의 결과`는 `상태에` 의존적이다.

하지만 뚱뚱하든 말랐든 엘리스 라는 `객체는 변하지 않는다.`

### 조금 어려운 말로 바꿔보자.

- 엘리스는 상태를 가진다.
- 상태를 변경시키는 것은 행동이다.
- 하지만 엘리스는 유일하게 식별 가능하다.

### 객체로 바꿔볼까?

- 상태
- 행동
- 식별자

> P.49
그러나 세상에 존재하는 모든 것들이 객체인 것은 아니다. 분명하게 인식할 수 있음에도 객체의 영역에 포함시킬 수 없는 것들도 존재한다. 엘리스의 키와 위치는 객체가 아니다. 음료와 케이크의 양은 객체가 아니다.
>

라는 구절이 있다.

하지만 이것 또한 객체일 수 있다고 생각한다.

자바에서는 원시 값을 쓰는 것을 지양한다. 왜일까?

생각해보자

[원시 타입을 포장해야 하는 이유](https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/)

### Value Object

> 값 객체(value object)는 식별자를 가지지 않는 값을 가리키는 용어이다.
>

즉, Integer, String 등등을 의미함

혹시 VO에 대해 아는지..?

Name name 이라면..?

그럼 Name은 동일성..?동등성..?

### 행동이 상태를 결정한다.

2장에서의 가장 핵심적인 키워드가 아닐까 싶다.

우리가 직접 설계를 할 때 가장 필요한 시각이다.

객체를 설계할 때 `애는 이걸 가지고 있어야 해!` 라고 생각하면 산으로 가는 경우가 많다.

`얘는 이런 행동(메세지)을 해야해!` 가 올바른 설계 방식인 것 같다.

뭔소리냐고?

단편적인 예를 들면 체스게임을 만들 때

체스판(Board)가 있다고 생각해보자

`체스판은 모든 기물들의 위치정보를 알고 있어야해!` 와 같은 상태를 규정하는 것보다는

`체스판은 피스들을 움직이는 역할을 해야 해!` 가 올바른 설계라는 말이다.

이 이유는 책에서는

1. 캡슐화가 저해
2. 객체를 협력자가 아닌 고립된 섬으로 만듬
3. 재사용성 떨어짐

으로 설명한다.

나는 2번이 가장 공감이 간다.

상태를 설계하고 들어가면 결국 `getter`를 사용하는 파괴적인 결말이 자주 나왔기 때문이다.

# 3장_타입과 추상화

### 추상화란?

구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.

→ 모든 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화 하는 것이라는 점을 기억하자.

추상화는 공통점을 취하는 방식이라고 생각한다.

Q. 그럼 추상화를 코드로 적용해서 얻을 수 있는 이점은 뭘까?

### 타입이란?

실제 메모리에는 타입이 없다.

즉, 메모리는 모두 같은 타입이다.

하지만 우리는 편의를 위해 타입을 구분하기 시작했다.

사칙연산이 되는 건 숫자, 다른 문자와 연결될 수 있으면 문자열 등등

결과적으로 타입의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다.

### 추상화와 일반화

추상화와 일반화의 레벨을 행동으로 규약하는 것은 신선했다.

추상화의 행동 개수 < 일반화의 행동 개수

### 타입의 목적

여기서 다시 한번 VO의 목적성이 나온다.

키는 VO로 사용한다면 시간의 따라 변하는 엘리스의 상태를 시간과 무관한 정적인 상태로 바꾸어준다.

엘리스가 키는 180 → 70 → 80 이라는 변화와 상관없이

`Height height` 만 가지고 있다면 시간에 독립적인 정적인 상태를 유지할 수 있다.
