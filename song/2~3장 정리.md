# 2장 이상한 나라의 객체

실세계를 컴퓨터 세상으로 구현하면 우리가 일반적으로 생각하는 방식으로 구현될 것이다.
하지만 겉으로는 우리가 알고있는 세계와 유사하지만 컴퓨터 세계에서의 객체는 자신이 맡은 일을 스스로 처리한다.

예를들면, 실세계의 전등은 켜주는 사람이 없다면 스스로 불을 낼 수 없지만 컴퓨터 세계에서는 스스로 전원을 켜거나 끈다.
또한 현실세계에서는 사람이 주문 금액을 계산하지만 컴퓨터 세게에서는 주문 객체가 금액을 계산한다.

### 객체, 그리고 이상한 나라

앨리스는 아름다운 정원으로 가기위해 작은 문 하나를 통과해야했다. 
문은 굉장히 작았기 때문에 몸을 줄여야했다. 몸을 줄인 후에 열쇠가 너무 커서 다시 키워야하는 경우도 생겨났다.

앨리스 이야기에서 엘리스를 하나의 객체로 바라본다면 앨리스의 키는 상태값을 의미하고 키를 줄이거나 키우는 행위는 행동을 의미한다.
앨리스가 하는 행동의 결과는 상태에 의존적이다. 이전 키가 몇인지에 따라 이후 키가 결정되기 때문이다.

'앨리스가 정원으로 이동한다'라는 행동의 결과 또한 상태값인 키에 따라 결정된다.
키가 문보다 작아야만 앨리스가 정원으로 이동할 수 있기 때문이다.

앨리스가 정원으로 이동하기 위해서는 음료를 마시거나 케이크를 먹어야 한다. 
이것은 행동 간의 순서가 중요하다는 것을 의미한다.

행동에 의해 상태값인 키가 바뀌더라도 앨리스가 앨리스라는 사실은 변하지 않는다.
따라서, 앨리스는 상태 병경과 무관하게 유일한 존재로 식별 가능하다.

앨리스 객체의 특징

- 앨리스는 상태를 가지며 상태는 변경 가능하다. -> 키, 위치등의 상태 값을 가진다.
- 앨리스의 상태를 변경시키는 것은 앨리스의 행동이다. -> 상태 값은 행위를 통해 변경 가능하다.
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다. -> 이전 키가 몇인지에 따라 변화된 키가 결정된다.
  - 행동의 순서가 결과에 영향을 미친다. -> 정원으로 가는 문을 통과하기 위해서는 키를 줄이기 위해 음료나 케이크를 먹어야 한다.
- 앨리스는 어떤 상태에 있더라도 유일하게 식별 가능하다. -> 상태 값인 키가 바뀌더라도 앨리스가 앨리스라는 사실이 변하지 않는다.

### 객체, 그리고 소프트웨어 나라

객체의 다양한 특성을 설명하려면 객체를 상태(State), 행동(Behavior), 식별자(identity)를 지닌 실체로 보는것이 효과적이다.

- 상태와 프로퍼티
  - 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다.
  - 프로퍼티는 단순한 값인 속성과 다른 객체를 가리키는 링크라는 두 가지 종류의 조합으로 표현된다.
- 행동 
  - 객체는 행동을 통해 상태를 변화시킨다.
  - 자기자신 뿐만 아니라 사용되는 객체의 상태를 변화시킬 수도 있다.
  - 행동의 결과는 상태에 의존적이다.
- 협력
  - 객체는 자신에게 주어진 책임을 완수하기 위해 다른 객체를 사용하고 다른 객체에게 서비스를 제공한다.
  - 객체끼리는 오직 메시지를 통해서만 의사소통할 수 있다.
- 캡슐화
  - 객체는 다른 객체의 상태를 알 수 없고, 오직 요청만을 보낼 수 있다. -> 결과적으로 어떻게 되는지 알 수도 알 필요도 없다.
  - 이는 상태를 잘 정의된 행동 집합 뒤로 숨겨 객체의 자율성을 높이고 협력을 단순하고 유연하게 만들어 준다.
- 식별자 
  - 모든 객체는 식별자를 가지며 식별자를 이용해 객체를 구별할 수 있다.

  > 동등성과 동일성
  > 
  > 동등성이란 상태를 이용해 값이 같은지를 판단하는 것이고, 동일성은 식별자를 이용해 동일한 객체인지 확인하는 것이다.

### ⭐ ️행동이 상태를 결정한다. ⭐️

상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 악영향을 끼친다.

1. 상태를 먼저 결정할 경우 캡슐화가 저해된다.
2. 객체를 협력자가 아닌 고립된 섬으로 만든다.
3. 객체의 재사용성이 저하된다.

> 3가지 모두 제대로된 협력을 할 수 없다는 점을 지적한다.
> 객체가 서로에게 협력하기 위해서는 행동이 상태를 결정하도록 해야한다.

### 의인화와 은유

'객체지향이란 현실 세계의 모방'이라는 것은 반은 맞고 반은 틀린 이야기이다.
사람들이 객체지향을 이해할때 현실 세계를 그대로 가져와서 구현하는 경우가 있다. 
하지만, 그렇게 구현하면 객체지향의 특성이 많이 사라지게 된다.

- 의인화
  - 현실 속의 객체와 소프트웨어 객체의 차이는 뭘까? 가장 큰 차이는 행동의 주체가 다르다는 점이다. 
  - 현실 속의 객체는 물건 혹은 추상적인 개념이 스스로 행동할 수 없다. 하지만, 소프트웨어 객체는 스스로 행동할 수 있다. 이를 의인화(anthropomorphism)라고 부른다.
- 은유
  - 현실 세계와 소프트웨어 세계 사이의 관계를 설명해줄 수 있는 단어는 은유다.
    은유는 하나의 의미를 다른 것을 이용해 전달한다는 의미를 가지고 있다.
  - 은유는 표현적 차이(representational gap) 또는 의미적 차이(semantic gap)라는 논점과 관련이 깊다.
  - 은유를 효과적으로 사용하면 표현적 차이를 줄여줄 수 있다. 
  - 현실세계에 빗대어 소프트웨어 세계를 구현하면 사람들이 쉽게 생각할 수 있다.


> 느낀점
> 
> 이 부분을 읽으면서 우테코 프리코스를 하면서 했던 실수가 생각이 난다.
> 나는 주로 객체를 만들 때 현실세계를 그대로 반영하려고 했었다. 
> 객체를 사용하는 유저를 만들어야 하는지에 대해 많이 고민했던 기억이 있다.
> 
> 또한 객체를 생각할 때 어떤 상태값이 필요한 지를 제일 먼저 고민했었다.
> 이는 객체가 서로 협력하기 어렵게 했던 이유였던 것 같다.
  

# 3장 타입과 추상화

### 추상화를 통한 복잡성 극복

추상화란 불필요한 것들을 배제하고 예측 가능한 수준으로 단순화하는 것을 말한다.

개념이란 공통점을 기반으로 객체들을 묶기 위한 그릇이다.

개념의 3가지 관점
1. 심볼(symbol) : 개념을 가리키는 간략한 이름이나 명칭 ex) 트럼프
2. 내연(intension) : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인 ex) 트럼프와 관련된 행동
3. 외연(extension) : 개념에 속하는 모든 객체의 집합 ex) 정원사, 병사, 신하, 왕자와 공주 등등

### 타입

타입과 개념의 정의는 완전히 동일하다. 타입에 속하는 객체 역시 타입의 인스턴스라고 한다.

객체에서 가장 중요한 요소는 행동이다. 결론적으로 객체의 타입을 결정하는 것은 객체의 행동 뿐이다.
두 객체가 동일한 데이터를 가지고 있더라도 다른 행동을 한다면 그 객체들은 서로 다른 타입으로 분류되어야 한다.

**다형성**이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 의미한다.
동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 처리할 수 있다. 
하지만, 처리하는 방식은 다를 수 있다.

훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. 이 원칙을 **캡슐화**라고 한다.

책임 주도 설계(RDD)는 도메인 주도 설계(DDD)의 단점을 보완하기 위해 나타났다.

> 행동과 관련이 없는 상태값은 있을 수 없는가?

### 일반화/특수화

객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이다.

객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다.

### 정적 모델

타입은 왜 사용해야 하는가? 객체를 지향하는 것은 객체만 생각하면 되는거 아닌가? 
타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복할 수 없기 때문이다.

결과적으로 타입은 추상화다. 

### 클래스

객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.
하지만, 클래스와 타입은 동일한 것이 아니다. 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다.

결과적으로 객체지향에서 중요한 것은 동적으로 변하는 객체의 '상태'와 상태를 변경하는 '행위'다.

> 느낀점
> 
> 3장에서는 추상화와 타입에 대해 설명하고 있다. 
> 추상화를 통해 단순화하고 행동을 통해 타입에 맞게 객체를 생성하자

<br/><br/><br/><br/><br/><br/><br/>